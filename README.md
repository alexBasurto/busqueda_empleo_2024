# BÚSQUEDA DE EMPLEO - 2024
<div style="display: flex; justify-content: space-evenly;">
    <img src="image-9.png" alt="Programador desesperado" style="width: 45%">
    <img src="image-10.png" alt="Programador desesperado" style="width: 45%">
</div>

El objetivo de este repositorio es, a medida que avanzo en el proceso de búsqueda de empleo, registrar las distintas pruebas técnicas y las preguntas relevantes que se me hagan en entrevistas técnicas. Y documentar aquellas que considere más interesantes.

--------------

## ENTREVISTAS Y PRUEBAS TÉCNICAS
Registro de preguntas y aspectos interesantes que han surgido en las entrevistas técnicas y en las pruebas técnicas.

--------------

### PARADIGMAS DE DESARROLLO
<!-- ![alt text](image-2.png) -->

<img src="image-2.png" alt="Paradigmas de desarrollo de software" style="width: 80%">

#### ¿Qué son los paradigmas de desarrollo?
Un paradigma de desarrollo en programación es un conjunto de principios, prácticas y patrones que guían la manera en que se diseña, desarrolla y estructura el código de un software. Esencialmente, representa una filosofía o enfoque particular para abordar problemas de programación.

Estos paradigmas no son reglas estrictas, sino más bien enfoques generales que proporcionan directrices sobre cómo se debe estructurar el código y cómo se deben resolver los problemas. Cada paradigma tiene sus propias características y técnicas distintivas, así como fortalezas y debilidades que lo hacen adecuado para diferentes tipos de problemas y contextos de desarrollo.

Por ejemplo, la programación orientada a objetos (POO) se centra en la organización del código en objetos que contienen tanto datos como comportamientos relacionados, promoviendo la reutilización y la modularidad del código. Mientras tanto, la programación funcional se basa en el uso de funciones puras y evita el estado mutable, lo que puede facilitar el razonamiento sobre el comportamiento del programa y reducir los errores.

En resumen, un paradigma de desarrollo proporciona un marco conceptual para pensar sobre el diseño y la implementación del software, y elegir el paradigma adecuado puede influir significativamente en la calidad, mantenibilidad y eficiencia del código resultante.

#### ¿Qué PARADIGMAS DE DESARROLLO conoces?
Estos son los tipos principales:

***Programación Imperativa/Procedural:***
Enfoque: Se centra en la descripción de los pasos específicos que un programa debe seguir para lograr un resultado.
Ejemplo: C, Pascal.

***Programación Orientada a Objetos (POO):***
Enfoque: Organiza el código en objetos que contienen tanto datos como comportamientos (métodos) relacionados.
Ejemplo: Java, Python.

***Programación Funcional:***
Enfoque: Se centra en las funciones puras, evitando el estado mutable y los efectos secundarios.
Ejemplo: Haskell, Lisp.

***Programación Lógica:***
Enfoque: Describe el problema en términos de relaciones lógicas y utiliza la inferencia lógica para resolverlo.
Ejemplo: Prolog.

***Programación Declarativa:***
Enfoque: Describe lo que se quiere lograr en lugar de cómo hacerlo, permitiendo que el sistema determine la mejor manera de ejecutar la tarea.
Ejemplo: SQL, HTML/CSS.

***Programación Orientada a Aspectos (AOP):***
Enfoque: Separa los aspectos transversales (como el registro y la seguridad) del código principal.
Ejemplo: AspectJ.

***Programación Reactiva:***
Enfoque: Se centra en la propagación automática de cambios de estado a través de la detección de eventos y la propagación de cambios.
Ejemplo: RxJava, ReactiveX.

Cada paradigma tiene sus propias fortalezas y debilidades, y la elección del paradigma adecuado depende del problema a resolver y de las preferencias del desarrollador.

--------------

### ANALISIS DEL CÓDIGO ESTÁTICO
<img src="image-3.png" alt="Analisis de código estático del software" style="width: 80%">

#### ¿Qué es el análisis del código estático?
El análisis estático de código es un proceso automatizado que examina el código fuente sin ejecutarlo. Identifica posibles errores, vulnerabilidades de seguridad, malas prácticas de codificación y oportunidades de mejora, todo ello mediante el escaneo del código en busca de patrones específicos predefinidos. Ayuda a mejorar la calidad del código, a reducir errores y a garantizar la consistencia y conformidad con estándares de codificación.

#### ¿Qué son las herramientas de ANÁLISIS ESTÁTICO del código?
Las herramientas de análisis estático de código son programas que examinan el código fuente de un software sin ejecutarlo. Su objetivo principal es identificar posibles problemas, vulnerabilidades, errores de estilo, malas prácticas y oportunidades de optimización en el código antes de que se ejecute.

#### Principales herramientas de ANALISIS ESTÁTICO DEL CÓDIGO

***ESLint:***
Descripción: ESLint es una herramienta de análisis estático para JavaScript que identifica patrones problemáticos en el código. Puede detectar errores de sintaxis, convenciones de estilo inconsistentes y problemas potenciales de seguridad.

***Pylint:***
Descripción: Pylint es una herramienta de análisis estático para Python que examina el código Python en busca de errores, estilos de codificación no conformes, redundancias y otros problemas. Proporciona una amplia gama de reglas configurables y puede integrarse con varias herramientas de desarrollo.

***SonarQube:***
Descripción: SonarQube es una plataforma de análisis estático de código que admite múltiples lenguajes de programación, incluidos Java, C#, JavaScript, Python y muchos más. Proporciona un análisis exhaustivo del código para detectar defectos, vulnerabilidades de seguridad, duplicación de código y otras métricas de calidad del código.

***Checkstyle:***
Descripción: Checkstyle es una herramienta de análisis estático de código para Java que se enfoca en el cumplimiento de convenciones de codificación y buenas prácticas. Puede identificar problemas como sangrías incorrectas, nombres de variables no descriptivos y otros estilos de codificación inconsistentes.

***RuboCop:***
Descripción: RuboCop es una herramienta de análisis estático de código para Ruby que ayuda a mantener un código Ruby limpio y coherente. Identifica problemas de estilo, convenciones de codificación no conformes y posibles errores lógicos en el código Ruby.

Estas herramientas de análisis estático son fundamentales para mejorar la calidad del código, garantizar la consistencia y facilitar la detección temprana de problemas, lo que contribuye a un desarrollo de software más eficiente y confiable.

--------------

### CONTROL DE VERSIONES
<img src="image-4.png" alt="Control de versiones" style="width: 80%">

#### ¿Qué es el control de versiones?
El control de versiones es un sistema que registra cambios en archivos y carpetas a lo largo del tiempo, lo que permite rastrear y administrar diferentes versiones de un proyecto de software. Facilita la colaboración entre equipos, ayuda a mantener un historial de cambios, y permite revertir a versiones anteriores si es necesario. Git es un ejemplo popular de sistema de control de versiones.

#### ¿Qué herramientas de CONTROL DE VERSIONES conoces?
Las herramientas de control de versiones son sistemas que ayudan a gestionar cambios en el código fuente y otros archivos de un proyecto de software. Estas herramientas registran cada modificación realizada en los archivos, lo que permite a los desarrolladores colaborar de manera efectiva, mantener un historial de cambios y revertir a versiones anteriores si es necesario. Aquí tienes algunas de las herramientas más populares y sus características principales:

***Git:***
Descripción: Git es un sistema de control de versiones distribuido ampliamente utilizado. Permite a los desarrolladores trabajar de forma independiente en sus propias copias del repositorio y fusionar los cambios cuando sea necesario. Git es conocido por su velocidad, eficiencia y flexibilidad, y es utilizado por grandes proyectos de código abierto y empresas.

***Subversion (SVN):***
Descripción: SVN es un sistema de control de versiones centralizado que utiliza un único repositorio central para almacenar el código fuente y sus historiales de cambios. A diferencia de Git, SVN no es distribuido, lo que significa que los desarrolladores necesitan acceso constante al repositorio central para realizar cambios.

***Mercurial (Hg):***
Descripción: Similar a Git, Mercurial es un sistema de control de versiones distribuido que permite a los desarrolladores trabajar de forma independiente y fusionar cambios posteriormente. Tiene una curva de aprendizaje más suave que Git y es conocido por su simplicidad y facilidad de uso.

***Perforce (Helix Core):***
Descripción: Perforce, anteriormente conocido como Helix Core, es un sistema de control de versiones centralizado que se utiliza principalmente en entornos empresariales y de desarrollo de videojuegos. Ofrece capacidades avanzadas de control de acceso y gestión de archivos binarios, lo que lo hace popular en industrias con grandes activos digitales.

***GitLab:***
Descripción: es una plataforma integral de gestión de proyectos de software que combina control de versiones Git con herramientas de seguimiento de problemas, CI/CD y colaboración. Permite a los equipos desarrollar, revisar, probar y desplegar aplicaciones de manera eficiente, todo en un solo lugar. Con características como registros de contenedores y control de acceso avanzado, GitLab es una solución popular para equipos de desarrollo en diversos entornos.

***Bitbucket:***
Descripción: plataforma de alojamiento de repositorios de código basada en Git y Mercurial. Permite a los equipos colaborar en proyectos de desarrollo de software, proporcionando herramientas para la gestión de repositorios, seguimiento de problemas, integración continua y despliegue automatizado. Además, ofrece características como control de acceso granular, revisión de código, seguimiento de cambios, y la posibilidad de crear y gestionar pipelines para la automatización de procesos de desarrollo.

#### ¿Cuáles son las principales funciones y características de las herramientas de control de versiones?
Las principales funciones y características con herramientas de control de versiones incluyen:

- Clonación del repositorio: Cada miembro del equipo clona el repositorio de control de versiones en su máquina local para obtener una copia de trabajo del proyecto.

- Creación de ramas (branches): Los desarrolladores crean ramas separadas para trabajar en nuevas características o correcciones de errores sin afectar el código principal. Luego, pueden fusionar sus cambios en la rama principal (trunk) cuando estén listos.

- Resolución de conflictos: Cuando dos o más desarrolladores modifican el mismo archivo, puede ocurrir un conflicto. Las herramientas de control de versiones proporcionan herramientas para resolver estos conflictos y fusionar los cambios de manera adecuada.

- Revisión de código (code review): Los equipos pueden utilizar características integradas o herramientas externas para realizar revisiones de código entre pares, donde los miembros del equipo revisan y comentan los cambios propuestos antes de fusionarlos en el repositorio principal.

El uso adecuado de las herramientas de control de versiones es fundamental para mantener un flujo de trabajo colaborativo y eficiente en proyectos de desarrollo de software.

#### Qué enfoques para el trabajo en equipo aplicas para evitar conflictos en el código?
El flujo de trabajo de GitFlow y el flujo de trabajo basado en troncos (o "trunk-based development") son dos enfoques diferentes para gestionar el flujo de trabajo de desarrollo en un repositorio Git. Aquí hay un resumen de cada uno:

***Flujo de trabajo de GitFlow:***

Branches principales:
- Master: Contiene el código en producción.
- Develop: Representa la integración continua del código en desarrollo.
- Branches de funcionalidad:
- Feature: Se ramifican desde develop y se utilizan para desarrollar nuevas características. Una vez completadas, se fusionan nuevamente en develop.
- Branches de publicación:
- Release: Se ramifican desde develop para preparar una nueva versión para el lanzamiento. Se realizan pruebas finales y correcciones de errores. Una vez lista, se fusiona en master y develop.
Branches de mantenimiento:
- Hotfix: Se ramifican desde master para corregir rápidamente errores críticos en producción. Una vez completados, se fusionan en master y develop.


***Flujo de trabajo basado en troncos:***

En el flujo de trabajo basado en troncos, hay una sola rama principal (a menudo master o main) que representa el código en producción. Los desarrolladores crean ramas de características (feature branches) para trabajar en nuevas funcionalidades. Una vez que una característica está completa y ha pasado las pruebas, se fusiona directamente en la rama principal. La integración continua y las pruebas automatizadas son fundamentales en este enfoque para garantizar la estabilidad del código principal en todo momento.

***Comparación***:

- *GitFlow*: Proporciona una estructura más formal y estática para el desarrollo, lo que puede ser útil en proyectos grandes con lanzamientos frecuentes y múltiples equipos trabajando simultáneamente en diferentes características. Sin embargo, puede ser complejo de administrar y puede generar conflictos de fusión cuando hay muchas ramas activas.
- *Flujo basado en troncos*: Es más simple y fomenta una integración continua más fluida. Es particularmente útil en proyectos más pequeños o en equipos donde se valora la velocidad y la simplicidad en el proceso de desarrollo. Sin embargo, puede volverse difícil de mantener a medida que el proyecto crece y la complejidad aumenta.
La elección entre estos dos enfoques depende de las necesidades específicas del proyecto, el tamaño del equipo, la frecuencia de los lanzamientos y otros factores. Algunas organizaciones incluso adaptan estos enfoques para crear su propio flujo de trabajo personalizado que se ajuste mejor a sus necesidades.

***Otros enfoques***:

El flujo de trabajo de GitFlow y el flujo de trabajo basado en troncos son dos de los enfoques más comunes y ampliamente utilizados en la industria del desarrollo de software. Sin embargo, no son los únicos enfoques disponibles, y es importante destacar que muchas organizaciones adaptan estos enfoques principales para satisfacer sus necesidades específicas.

Además de GitFlow y el flujo de trabajo basado en troncos, existen otros enfoques y metodologías que algunas organizaciones utilizan, como:

- *GitLab Flow*: Similar a GitFlow, pero simplificado y centrado en GitLab como plataforma de gestión de código.
- *GitHub Flow*: Un enfoque ligero y basado en la rama principal, promovido por GitHub. Es similar al flujo de trabajo basado en troncos, pero con un énfasis aún mayor en la integración continua y las pruebas automatizadas.
- *Feature Toggles*: En lugar de mantener múltiples ramas de desarrollo, los equipos pueden optar por desarrollar funcionalidades en la rama principal, pero con el código de nuevas funcionalidades oculto detrás de "toggles" o interruptores que se pueden activar y desactivar según sea necesario.
- *GitOps*: Un enfoque que utiliza Git como fuente de verdad para la infraestructura y la entrega continua, lo que permite a los equipos gestionar la infraestructura como código y automatizar los despliegues.
- *Continuous Deployment*: En lugar de trabajar en ramas separadas, algunos equipos adoptan un enfoque de despliegue continuo donde cada cambio que pasa las pruebas automatizadas se implementa directamente en producción.

La elección del enfoque de flujo de trabajo depende de una variedad de factores, como el tamaño del equipo, la naturaleza del proyecto, la frecuencia de los lanzamientos, las preferencias del equipo y las herramientas disponibles. En última instancia, cada equipo y organización debe evaluar y seleccionar el enfoque que mejor se adapte a sus necesidades y procesos.

--------------

### DOCUMENTACIÓN
<img src="image-5.png" alt="Documentación de software" style="width: 80%">

#### ¿Por qué es importante la DOCUMENTACIÓN en el desarrollo de software?

La documentación en el desarrollo de software es crucial para garantizar la comprensión, mantenibilidad y escalabilidad de los proyectos. Hay varios tipos de documentación que pueden ser generados manualmente o automáticamente, cada uno con sus propias ventajas:

#### ¿Qué formas de hacer documentación existen?
***Documentación Generada Manualmente:***

- *Documentación de Requisitos*: Describe los requisitos funcionales y no funcionales del software desde la perspectiva del usuario.
- *Documentación de Diseño*: Detalla la arquitectura del sistema, incluyendo diagramas de clases, diagramas de flujo, y otros artefactos que explican cómo se estructura y se comporta el software.
- *Documentación de Usuario*: Proporciona instrucciones detalladas sobre cómo instalar, configurar y utilizar el software. Puede incluir manuales de usuario, guías de inicio rápido y documentación en línea.
- *Documentación de API*: Describe cómo interactuar con las interfaces de programación de aplicaciones (API) proporcionadas por el software, incluyendo descripciones de endpoints, parámetros y ejemplos de solicitudes y respuestas.
- *Documentación de Proceso*: Describe los procesos de desarrollo y las prácticas de ingeniería de software utilizadas en el proyecto, como estándares de codificación, metodologías de desarrollo y políticas de control de versiones.

***Documentación Generada Automáticamente:***

- *Documentación de Código Fuente*: Generada a partir de comentarios en el código fuente utilizando herramientas como Doxygen, Javadoc o Sphinx. Ayuda a entender la estructura y funcionamiento del código.
- *Documentación de Pruebas*: Automáticamente generada a partir de resultados de pruebas automatizadas, proporcionando informes detallados sobre el estado de las pruebas unitarias, de integración y de aceptación.
- *Diagramas de Arquitectura Automatizados*: Herramientas como PlantUML o Graphviz pueden generar diagramas de arquitectura automáticamente a partir de archivos de configuración o código fuente, lo que ayuda a mantener la documentación de diseño actualizada.

#### ¿Qué generadores de documentación existen?

- Generadores de documentación para JavaScript y TypeScript:
    - **JSDoc**:
        Tipo de Herramienta: Generador de documentación de código para JavaScript.
        Funcionalidad: Permite agregar comentarios de estilo JSDoc al código JavaScript para documentar funciones, métodos, variables y otros elementos del código.
        Salida: Genera documentación en formato HTML a partir de los comentarios JSDoc, que incluye descripciones, tipos de datos, parámetros, valores de retorno y más.
        Ámbitos de Uso: Ampliamente utilizado en proyectos de desarrollo de JavaScript y Node.js para crear documentación clara y legible del código.
    - **ESDoc:**
        Tipo de Herramienta: Generador de documentación de código para JavaScript y ECMAScript.
        Funcionalidad: Similar a JSDoc, ESDoc permite documentar código JavaScript utilizando comentarios especiales.
        Características: Proporciona una sintaxis simple y fácil de usar, junto con una variedad de plugins para extender su funcionalidad.
        Salida: Genera documentación en formato HTML, junto con otros formatos como JSON, Markdown y YAML.
        Ámbitos de Uso: Utilizado en proyectos de desarrollo de JavaScript y ECMAScript para generar documentación clara y detallada del código.
    - **TypeDoc:**
        Tipo de Herramienta: Generador de documentación de código para TypeScript.
        Funcionalidad: Permite documentar código TypeScript utilizando comentarios JSDoc, pero también puede extraer automáticamente información de tipos TypeScript.
        Características: Especialmente útil para proyectos escritos en TypeScript, ya que puede documentar interfaces, tipos, módulos y más de manera automática.
        Salida: Genera documentación en formato HTML, similar a JSDoc y ESDoc.
        Ámbitos de Uso: Ampliamente utilizado en proyectos de desarrollo de TypeScript para crear documentación precisa y completa del código.
- Generadores de documentación para otros lenguajes:
    - **Doxygen**:
        Lenguajes de Programación: C, C++, Java, Python, PHP, entre otros.
        Funcionalidad: Genera documentación a partir de comentarios especiales en el código fuente en una variedad de formatos, incluyendo HTML, LaTeX y RTF.
    - **Sphinx**:
        Lenguajes de Programación: Python (principalmente), pero compatible con otros lenguajes.
        Funcionalidad: Utilizado principalmente para documentación de Python, pero puede ser utilizado para otros lenguajes. Permite escribir documentación en formato reStructuredText y genera la documentación en HTML, PDF, ePub, entre otros.
    - **DocFX**:
        Lenguajes de Programación: C#, F#, VB.NET, Markdown, YAML, JSON.
        Funcionalidad: Utilizado principalmente para documentación de proyectos .NET, pero también compatible con otros formatos. Permite escribir documentación en Markdown y genera la documentación en HTML, PDF y otros formatos.
    - **Javadoc**:
        Lenguajes de Programación: Principalmente Java.
        Funcionalidad: Genera documentación a partir de comentarios especiales en el código fuente en formato HTML. Es una herramienta estándar para la documentación de proyectos Java.
    - **VuePress**:
        Lenguajes de Programación: Principalmente para proyectos basados en Vue.js, pero puede ser utilizado para otros lenguajes.
        Funcionalidad: Utiliza Markdown para escribir documentación y genera la documentación en HTML estático. Es especialmente útil para proyectos de Vue.js y documentación de bibliotecas y componentes.
    - **MkDocs**:
        Lenguajes de Programación: Cualquier lenguaje compatible con Markdown.
        Funcionalidad: Utiliza Markdown para escribir documentación y genera la documentación en HTML estático. Es simple de configurar y utilizar, lo que lo hace popular para proyectos de documentación estática.

#### ¿Qué ventajas aporta la documentación?

- Facilita la Comprensión: Permite a los desarrolladores y usuarios entender el propósito, funcionamiento y uso del software.
- Mejora la Mantenibilidad: Una documentación clara y completa facilita la identificación y corrección de problemas, así como la realización de modificaciones en el código.
- Promueve la Colaboración: Facilita la colaboración entre miembros del equipo al proporcionar una referencia común y clara para el trabajo.
- Acelera el Aprendizaje: Ayuda a los nuevos miembros del equipo a familiarizarse rápidamente con el proyecto y a contribuir de manera efectiva.
- Apoya el Cumplimiento y la Auditoría: Proporciona un registro de los requisitos, decisiones de diseño, pruebas y cambios realizados en el software, lo que puede ser útil para fines de cumplimiento y auditoría.
En resumen, la documentación en el desarrollo de software, ya sea generada manualmente o automáticamente, es esencial para asegurar la calidad, mantenibilidad y éxito a largo plazo de los proyectos de software.

--------------

### TESTING
<img src="image-6.png" alt="Testing de software" style="width: 80%">

#### ¿Qué es el tésting? ¿Qué aporta?
El testing en desarrollo de software es el proceso de verificar y validar el comportamiento de un programa para garantizar que cumpla con los requisitos y expectativas establecidos. Se realizan pruebas sistemáticas para identificar errores y garantizar la calidad del software antes de su lanzamiento.

### ¿Qué tipos de testing existen?
Hay varios tipos de pruebas que se pueden realizar, cada uno con su propio enfoque y beneficios:

***Pruebas Unitarias:***
Se centran en probar unidades individuales de código, como funciones o métodos.
Se escriben y ejecutan por los propios desarrolladores.
Ventajas: Identifican rápidamente errores en unidades de código específicas, promueven el diseño modular y facilitan la detección temprana de fallos.

***Pruebas de Integración:***
Verifican la interacción y la comunicación entre diferentes módulos o componentes del sistema.
Se aseguran de que las partes del sistema funcionen correctamente juntas.
Ventajas: Detectan problemas de integración entre componentes, garantizan la interoperabilidad y ayudan a validar el comportamiento del sistema como un todo.

***Pruebas de Aceptación del Usuario (UAT):***
Realizadas por usuarios finales o representantes del cliente para validar si el software cumple con los requisitos y expectativas.
Se enfocan en la funcionalidad y la usabilidad desde la perspectiva del usuario.
Ventajas: Garantizan que el software satisfaga las necesidades del usuario final, identifican posibles mejoras desde la perspectiva del usuario y aumentan la satisfacción del cliente.

***Pruebas de Regresión:***
Se realizan para asegurar que los cambios recientes en el código no han introducido nuevos errores o afectado negativamente la funcionalidad existente.
Pueden ser automatizadas para ejecutarse de manera eficiente en cada iteración de desarrollo.
Ventajas: Protegen contra la introducción de regresiones en el código, garantizan la estabilidad del sistema a medida que evoluciona y ahorran tiempo al automatizar pruebas repetitivas.

***Pruebas de Estrés y Rendimiento:***
Evalúan cómo se comporta el sistema bajo cargas de trabajo extremas o condiciones adversas.
Se centran en la capacidad de respuesta, la escalabilidad y el rendimiento del software.
Ventajas: Identifican cuellos de botella y puntos de fallo bajo condiciones de estrés, permiten optimizar el rendimiento y la escalabilidad del sistema y garantizan una experiencia de usuario fluida incluso en condiciones adversas.

***Pruebas de Seguridad:***
Buscan identificar vulnerabilidades y riesgos de seguridad en el software.
Se centran en aspectos como la autenticación, autorización, cifrado y protección contra ataques.
Ventajas: Mitigan riesgos de seguridad, protegen datos sensibles y aseguran la confidencialidad, integridad y disponibilidad del sistema.
Cada tipo de prueba tiene su propósito y contribuye de manera única a garantizar la calidad y fiabilidad del software. Al combinar diferentes tipos de pruebas en un enfoque integral de calidad, los equipos de desarrollo pueden minimizar el riesgo de fallos y ofrecer productos que satisfagan las necesidades y expectativas de los usuarios.

#### Programas de testing de desarrollo software
Aquí tienes una lista de algunos de los principales programas y frameworks de testing, junto con el tipo de testing para el que se utilizan y los ámbitos de uso más comunes:

- **JUnit**
Tipo de Testing: Pruebas unitarias en Java.
Ámbitos de Uso: Ampliamente utilizado en el desarrollo de software en Java para realizar pruebas unitarias.
- **PyTest**
Tipo de Testing: Pruebas unitarias y de integración en Python.
Ámbitos de Uso: Utilizado en proyectos de desarrollo de software en Python para escribir y ejecutar pruebas unitarias y de integración.
- **Selenium**
Tipo de Testing: Pruebas de integración y funcionales para aplicaciones web.
Ámbitos de Uso: Utilizado para realizar pruebas automatizadas en aplicaciones web en diferentes navegadores y sistemas operativos.
- **Cucumber**
Tipo de Testing: Pruebas de aceptación del usuario (UAT) y pruebas de comportamiento (BDD).
Ámbitos de Uso: Utilizado para escribir pruebas de aceptación del usuario en un formato legible por humanos y para facilitar la colaboración entre equipos de desarrollo y stakeholders.
- **JUnit Jupiter (parte de JUnit 5)**
Tipo de Testing: Pruebas unitarias en Java (siguiente versión de JUnit).
Ámbitos de Uso: Utilizado en proyectos de desarrollo de software en Java para realizar pruebas unitarias con la última versión de JUnit.
- **Robot Framework**
Tipo de Testing: Pruebas de aceptación del usuario (UAT) y pruebas de automatización de procesos.
Ámbitos de Uso: Ampliamente utilizado para escribir pruebas de aceptación del usuario y pruebas de automatización de procesos en una variedad de lenguajes de programación y tecnologías.
- **Postman**
Tipo de Testing: Pruebas de API y servicios web.
Ámbitos de Uso: Utilizado para escribir y ejecutar pruebas automatizadas en APIs y servicios web, así como para la documentación de APIs y la colaboración en equipos de desarrollo.
- **JUnit Vintage (parte de JUnit 5)**
Tipo de Testing: Pruebas unitarias en Java (compatibilidad con versiones anteriores de JUnit).
Ámbitos de Uso: Utilizado en proyectos de desarrollo de software en Java para realizar pruebas unitarias con versiones anteriores de JUnit.
- **Para JavaScript**:
        - **Mocha**:
        Descripción: Mocha es un popular framework de pruebas para JavaScript que proporciona una estructura flexible y potente para escribir pruebas unitarias y de integración.
        - **Jest**:
        Descripción: Jest es un framework de pruebas desarrollado por Facebook, diseñado para ser fácil de configurar y utilizar. Es conocido por su velocidad y capacidad para ejecutar pruebas de forma paralela.
        - **Jasmine**:
        Descripción: Jasmine es otro framework de pruebas para JavaScript que se centra en la legibilidad y expresividad del código de prueba. Proporciona una sintaxis de estilo BDD (Behavior-Driven Development) que resulta intuitiva para muchos desarrolladores.
        - **Cypress**:
        Descripción: Cypress es una herramienta de prueba de extremo a extremo para aplicaciones web modernas. Permite escribir y ejecutar pruebas automatizadas en un entorno controlado y ofrece herramientas avanzadas para depurar y entender el comportamiento de las pruebas.

- **Para TypeScript:**
        - **Jest (con soporte para TypeScript):**
        Descripción: Jest es compatible con TypeScript y puede utilizarse fácilmente para escribir pruebas en proyectos que utilizan TypeScript. Puede manejar archivos TypeScript directamente o puede utilizarse en combinación con herramientas como ts-jest para mejorar la integración con TypeScript.
        - **Mocha con Chai y Sinon (con soporte para TypeScript):**
        Descripción: Mocha es compatible con TypeScript y puede combinarse con las bibliotecas de aserciones Chai y los mocks y stubs Sinon para escribir pruebas robustas y expresivas en proyectos de TypeScript.
        - **Jasmine (con soporte para TypeScript):**
        Descripción: Jasmine también es compatible con TypeScript y puede utilizarse para escribir pruebas en proyectos que utilizan este lenguaje. Proporciona una sintaxis de estilo BDD que puede resultar intuitiva para muchos desarrolladores.


Estos son solo algunos ejemplos de programas y frameworks de testing que se utilizan en diferentes contextos y para diferentes tipos de pruebas. La elección del programa o framework adecuado dependerá del tipo de testing que necesites realizar, el lenguaje de programación que estés utilizando y las necesidades específicas de tu proyecto.

#### ¿Por qué es importante el Testing?

El testing es fundamental en el desarrollo de software por varias razones importantes:

- Garantiza la Calidad del Software: Las pruebas ayudan a identificar errores y defectos en el código antes de que el software se entregue a los usuarios finales, lo que contribuye a la entrega de un producto de alta calidad.
Mejora la Fiabilidad: Al realizar pruebas exhaustivas, se puede aumentar la confianza en la estabilidad y fiabilidad del software, reduciendo la probabilidad de fallos inesperados en producción.
- Ahorra Costos: Identificar y corregir errores durante el proceso de desarrollo es más económico que hacerlo una vez que el software está en producción. Las pruebas ayudan a detectar problemas temprano, lo que reduce los costos asociados con la resolución de errores.
- Facilita el Mantenimiento: Las pruebas bien diseñadas actúan como una protección contra la introducción de nuevos errores al realizar cambios en el código existente. Esto hace que el mantenimiento y la evolución del software sean más eficientes y seguros.
- Aumenta la Confianza del Cliente: La realización de pruebas rigurosas demuestra el compromiso con la calidad por parte del equipo de desarrollo, lo que aumenta la confianza del cliente en el producto entregado.
- Mejora la Experiencia del Usuario: Al detectar y corregir errores antes del lanzamiento, se garantiza una experiencia de usuario más fluida y satisfactoria, lo que contribuye a la satisfacción del cliente y la retención de usuarios.
- Facilita la Identificación de Requisitos Incorrectos: Las pruebas ayudan a validar los requisitos del software al verificar que el software se comporte como se espera en diferentes escenarios, lo que facilita la identificación de posibles malentendidos o ambigüedades en los requisitos.

En resumen, el testing es importante porque contribuye significativamente a la calidad, fiabilidad y éxito general del software, al tiempo que ayuda a reducir riesgos, costos y tiempos de entrega.

--------------

## Registro de pruebas técnicas
Aspectos más relevantes que me he encontrado en las distintas pruebas técnicas

-   Empresa 1: desarrollo con HTML-CSS planos y JS Vanila de dos ejercicios:
    - Ejercicio 1 - Formularios y validaciones:
    Se quiere que se haga un formulario donde se pida nombre, apellido y edad de una persona. Además que haya un botón para envío de la información. Se pueden usar estilos que se deseen, pero debe hacerse con HTML y CSS plano. Se quiere que el formulario tenga una serie de validaciones que deben ser hechas con JavaScript y no con las validaciones de HTML: el nombre y el apellido deben ser tipo string y con una longitud mínima de 3 caracteres. La edad debe ser número y mayor de 18.
    Al hacer click en el botón de Enviar debe aparecer en pantalla (dentro del recuadro negro) la información introducida por el usuario, con la misma estructura que tiene el formulario, es decir nombre: xxxx , apellido: xxxx, edad: xxxx. En caso de que el usuario meta información que no cumpla con la validación del input debe especificarse debajo de
    cada input con el mensaje : "El nombre no es válido"/"El apellido no es válido" o "La edad no es válida".
    - Ejercicio 2 – Llamadas API y mapeo de datos:
    Queremos crear una vista con un listado de posts en los que podremos hacer click para ver el detalle de cada post.
    Para hacer este ejercicio se quiere que se haga una consulta al API: https://jsonplaceholder.typicode.com/posts .
    Una vez obtengamos la respuesta del servicio necesitamos añadir una propiedad a cada elemento del array, esta
    propiedad se llamará ‘published’ y le asignaremos el valor de la función ‘randomBoolean’ del archivo randomData.js
    que se encuentra en carpeta helpers.
    Mostraremos el título de cada post en un listado por pantalla filtrando solo los que tengan la propiedad ‘publised’ a
    true(primera pantalla de arriba). Los datos se deben inyectar en el HTML de manera dinámica desde JavaScript en
    el div con el id 'posts' del archivo index.html.
    Al hacer click en cada post debemos navegar a otra página llamada detalle.html pasando por parámetro en la url el
    id del post.
    En la página detalle.html se recuperará el id del post y se hará una llamada al API
    https://jsonplaceholder.typicode.com/posts/{id} y se mostrarán los siguientes datos en el div con el id 'post', los
    datos se deben inyectar en el HTML desde JavaScript.
    Se proporcionará la estructura básica del proyecto y se ampliará o modificará según se necesite.
    Requisitos:
        - Usar solo JavaScript Vanilla (No TypeScript), HTML y CSS
        - Uso de módulos de JavaScript
        - Uso de fetch nativo
        - Extras:
            - Uso de promesas (No Async Await)
            - Uso de clases en los casos que corresponda
            - Manejo de errores
- Empresa 2 prueba técnica puesto Full Stack + Cloud (con Java):
    Prueba en HackerRank con: 
    - 1 ejercicio tipo Kata de código en java.
    - 14 preguntas de tipo test. 6 de única respuesta y 7 de multiple respuesta. Temáticas:
        - Java
        - SQL
        - Metodos HTTP
- Empresa 2 prueba técnica puesto Front End:
    - 1 ejercicio tipo Kata de código en JS donde tenía que escribir una función generadora con ```yield```.
- Empresa 3- puesto Full Stack Mern/Sern en StartUp:
    - Desarrllo de un e-commerce sencillo y sin funcionalidad real de compra. Función de renderizado de productos y carrito.